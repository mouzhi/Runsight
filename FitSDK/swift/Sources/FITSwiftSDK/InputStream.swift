/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

public class InputStream {
    private let data: Data
    public private(set) var position: Int = 0
    
    enum InputStreamError: Error {
        case positionIndexOutOfRange
        case numberOfBytesProvidedIsLongerThanNumberOfBytesRemaining
    }
    
    public init(data: Data) {
        self.data = data
        self.position = 0;
    }
    
    public func readNumeric<T>(endianness: Endianness = Endianness.little) throws -> T {
        let size = MemoryLayout<T>.size
        
        if (size > data.count - position) {
            throw InputStreamError.numberOfBytesProvidedIsLongerThanNumberOfBytesRemaining
        }
        
        var subdata = data.subdata(in: position..<position+size)
        
        if (endianness == Endianness.big) {
            subdata.reverse()
        }
        
        let value:T =  subdata.withUnsafeBytes({
            $0.load(as: T.self)
        })
        
        position += size
        
        return value
    }
    
    public func readString(size:UInt8) throws -> String {
        if (size > data.count - position) {
            throw InputStreamError.numberOfBytesProvidedIsLongerThanNumberOfBytesRemaining
        }
        
        let stringData = data.subdata(in: position..<position+Int(size))
        let string = String(decoding: stringData, as: UTF8.self)
        
        position += Int(size)
        
        return string
    }
    
    public func reset() throws -> Void {
        try seek(position: 0);
    }
    
    public func seek(position: Int) throws -> Void {
        if (position > data.count - 1) {
            throw InputStreamError.positionIndexOutOfRange
        }
        self.position = position;
    }
    
    public func peekByte() -> UInt8 {
        let value: UInt8 =  data.subdata(in: position..<position+1).withUnsafeBytes({ $0.load(as: UInt8.self) })
        return value;
    }
        
    var hasBytesAvailable: Bool {
        return position < data.count
    }
    
    // MARK: Array Like Methods
    public var count: Int {
        return data.count
    }
    
    public subscript(bounds: Range<Data.Index>) -> Data {
        return self.data[bounds]
    }

    public subscript(bounds: ClosedRange<Data.Index>) -> Data {
        return self.data[bounds]
    }
    
    public subscript(index: Int) -> UInt8 {
        return self.data[index]
    }
}

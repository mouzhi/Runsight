/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

open class FieldBase: Equatable {
    var values: [Any?] = []
    
    enum FieldError: Error {
        case invalidSubFieldIndex(subFieldIndex: UInt16)
        case invalidSubFieldName(subFieldName: String)
        case sizeOverflow(size: Int)
        case unsupportedOS(minVersion:String)
    }
    
    // MARK: Initializers
    public init(fieldBase: FieldBase) {
        self.values += fieldBase.values
    }
    
    init() {
        
    }
    
    public func getName() -> String {
        preconditionFailure("This method must be overridden")
    }
    
    public func getNum() -> UInt8 {
        preconditionFailure("This method must be overridden")
    }
    
    func getScale() -> Float64 {
        preconditionFailure("This method must be overridden")
    }
    
    func getOffset() -> Float64 {
        preconditionFailure("This method must be overridden")
    }
    
    public func getUnits() -> String {
        preconditionFailure("This method must be overridden")
    }
    
    public func getBaseType() -> BaseType {
        preconditionFailure("This method must be overridden")
    }
    
    // MARK: Get Value
    public func getValue() -> Any? {
        return getValue(index: 0, subField: nil)
    }
    
    public func getValue(index: Int) -> Any? {
        return getValue(index: index, subField: nil)
    }
    
    public func getValue(index: Int, subFieldIndex: UInt16) throws -> Any? {
        var subField:SubField? = nil
        
        if (subFieldIndex != FIT.SUBFIELD_INDEX.MAIN_FIELD) {
            subField = getSubField(subFieldIndex: Int(subFieldIndex))
            
            if (subField == nil) {
                throw FieldError.invalidSubFieldIndex(subFieldIndex: subFieldIndex)
            }
        }
        
        return getValue(index: index, subField: subField)
    }
    
    public func getValue(index: Int, subFieldName: String) throws -> Any? {
        guard let subField = getSubField(subFieldName: subFieldName) else {
            throw FieldError.invalidSubFieldName(subFieldName: subFieldName)
        }
        
        return getValue(index: index, subField: subField)
    }
    
    func getValue(index: Int, subField: SubField?) -> Any? {
        guard var value = getValidatedRawValue(index: index, subField: subField) else {
            return nil;
        }

        if (getBaseType().isNumeric) {
            let scale = subField?.scale ?? getScale()
            let offset = subField?.offset ?? getOffset()

            if(scale != FIT.FIELD_DEFAULT_SCALE || offset != FIT.FIELD_DEFAULT_OFFSET) {
                value = Float64(fitValue: value) / scale - offset
            }
        }
        
        return value
    }

    func getValidatedRawValue(index: Int, subField: SubField?) -> Any? {
        guard let value = getRawValue(index: index) else {
            return nil
        }
        
        let isValid = !(subField?.baseType ?? getBaseType()).isInvalid(value)
        guard isValid else {
            return nil
        }
        
        return value;
    }
    
    public func getRawValue(index: Int) -> Any? {
        return values[safe: index] ?? nil
    }
    
    // MARK: Set Value
    public func setValue(value: Any?) throws {
        try setValue(index: 0, value: value, subField: nil)
    }
    
    public func setValue(index: Int, value: Any?) throws {
        try setValue(index: index, value: value, subField: nil)
    }
    
    public func setValue(value: Any?, subFieldIndex: UInt16) throws {
        try setValue(index: 0, value: value, subFieldIndex: subFieldIndex)
    }
    
    public func setValue(value: Any?, subFieldName: String) throws {
        guard let subField = getSubField(subFieldName: subFieldName) else {
            throw FieldError.invalidSubFieldName(subFieldName: subFieldName)
        }
        
        try setValue(index: 0, value: value, subField: subField)
    }
    
    public func setValue(index: Int, value: Any?, subFieldIndex: UInt16) throws {
        var subField:SubField? = nil
        
        if (subFieldIndex != FIT.SUBFIELD_INDEX.MAIN_FIELD) {
            subField = getSubField(subFieldIndex: Int(subFieldIndex))

            if (subField == nil) {
                throw FieldError.invalidSubFieldIndex(subFieldIndex: subFieldIndex)
            }
        }
        
        try setValue(index: index, value: value, subField: subField)
    }
    
    func setValue(index: Int, value: Any?, subField: SubField?) throws {
        try checkFieldSizeWithValue(index: index, value: value)
        
        while (index >= values.count) {
            values.append(nil)
        }
        
        if (value == nil) {
            values[index] = nil
            return
        }
        
        let baseType = getBaseType()

        if (baseType == .STRING) {
            values[index] = String(anyValue: value)
            return
        }

        var rawValue = Double(fitValue: value)
        
        let scale = subField?.scale ?? getScale()
        let offset = subField?.offset ?? getOffset()
        let hasScaleOrOffset = (scale != FIT.FIELD_DEFAULT_SCALE) || (offset != FIT.FIELD_DEFAULT_OFFSET)

        if (baseType.isNumeric && hasScaleOrOffset) {
            rawValue = (Double(fitValue: value) + Double(fitValue: offset)) * Double(fitValue: scale)

            rawValue = baseType.isFloatingPoint ? rawValue : rawValue.rounded()
        }

        values[index] = baseType.correctRangeAndType(rawValue)
    }
    
    // MARK: Add Raw Value
    public func addRawValue(_ value: Any?) throws {
        try checkFieldSizeWithValue(index: values.endIndex, value: value)
        
        guard let value else {
            values.append(nil)
            return
        }
        
        let baseType = getBaseType()

        if (baseType == .STRING) {
            values.append(String(anyValue: value))
            return
        }
        
        let correctedValue = baseType.correctRangeAndType(Double(fitValue: value))

        values.append(correctedValue)
    }
    
    // MARK: Read InputStream
    func read(stream: InputStream, size: UInt8, endianness: Endianness = Endianness.little) throws -> Void {
        if (getBaseType() == .STRING) {
            let value = try stream.readString(size: size )
            
            for split in value
                .trimTrailingNullTerminators()
                .split(separator: "\0", omittingEmptySubsequences: false) {
                values.append(String(split))
            }
            
            return
        }
        
        var hasValidValues = false;
        
        let count = size / getBaseType().size
        for _ in 0..<count {
            var value: Any? = nil
            
            switch getBaseType() {
            case .ENUM:
                value = try stream.readNumeric(endianness: endianness) as UInt8
            case .SINT8:
                value = try stream.readNumeric(endianness: endianness) as Int8
            case .UINT8:
                value = try stream.readNumeric(endianness: endianness) as UInt8
            case .SINT16:
                value = try stream.readNumeric(endianness: endianness) as Int16
            case .UINT16:
                value = try stream.readNumeric(endianness: endianness) as UInt16
            case .SINT32:
                value = try stream.readNumeric(endianness: endianness) as Int32
            case .UINT32:
                value = try stream.readNumeric(endianness: endianness) as UInt32
            case .FLOAT32:
                value = try stream.readNumeric(endianness: endianness) as Float32
                if(getBaseType().isInvalid(value)) {
                    value = nil
                }
            case .FLOAT64:
                value = try stream.readNumeric(endianness: endianness) as Float32
                if(getBaseType().isInvalid(value)) {
                    value = nil
                }
            case .UINT8Z:
                value = try stream.readNumeric(endianness: endianness) as UInt8
            case .UINT16Z:
                value = try stream.readNumeric(endianness: endianness) as UInt16
            case .UINT32Z:
                value = try stream.readNumeric(endianness: endianness) as UInt32
            case .BYTE:
                value = try stream.readNumeric(endianness: endianness) as UInt8
            case .SINT64:
                value = try stream.readNumeric(endianness: endianness) as Int64
            case .UINT64:
                value = try stream.readNumeric(endianness: endianness) as UInt64
            case .UINT64Z:
                value = try stream.readNumeric(endianness: endianness) as UInt64
            case .STRING:
                break
            }
            
            hasValidValues = getBaseType().isValid(value) || hasValidValues
            values.append(value)
        }
        
        if(!hasValidValues) {
            values.removeAll();
        }
    }
    
    // MARK: Write OutputStream
    func write(outputStream: OutputStream) {
        for value in values {
            if (getBaseType().isInvalid(value)) {
                outputStream.append(contentsOf: getBaseType().invalidBytes)
                continue
            }
            
            writeValue(outputStream: outputStream, value: value!)
        }
    }
    
    private func writeValue(outputStream: OutputStream, value: Any) {
        switch getBaseType() {
        case .STRING:
            outputStream.append(contentsOf: Array((value as! String).utf8))
            // Null terminate the string
            outputStream.append(value: UInt8(0))
        default:
            outputStream.append(value: value as! (any Numeric))
        }
    }
    
    
    // MARK: Get SubFields
    
    func getSubField(subFieldIndex: Int) -> SubField? {
        preconditionFailure("This method must be overridden")
    }
    
    func getSubField(subFieldName: String) -> SubField? {
        preconditionFailure("This method must be overridden")
    }
    
    // MARK: Equatable
    public static func == (lhs: FieldBase, rhs: FieldBase) -> Bool {
        return lhs.getNum() == rhs.getNum() &&
        lhs.getBaseType() == rhs.getBaseType() &&
        lhs.getScale() == rhs.getScale() &&
        lhs.getOffset() == rhs.getOffset() &&
        lhs.getUnits() == rhs.getUnits() &&
        lhs.getName() == rhs.getName() &&
        lhs.hasEqualValues(rhs: rhs)
    }
    
    func hasEqualValues(rhs: FieldBase) -> Bool {
        let lhs = self
        
        guard lhs.values.count == rhs.values.count else {
            return false
        }
        
        for (lhsValue, rhsValue) in zip(lhs.values, rhs.values) {
            let isEqual = switch lhs.getBaseType() {
            case .ENUM, .UINT8, .UINT8Z, .BYTE: (lhsValue as! UInt8 == rhsValue as! UInt8)
            case .SINT8: (lhsValue as! Int8 == rhsValue as! Int8)
            case .SINT16: (lhsValue as! Int16 == rhsValue as! Int16)
            case .UINT16, .UINT16Z: (lhsValue as! UInt16 == rhsValue as! UInt16)
            case .SINT32: (lhsValue as! Int32 == rhsValue as! Int32)
            case .UINT32, .UINT32Z: (lhsValue as! UInt32 == rhsValue as! UInt32)
            case .FLOAT32: (lhsValue as! Float32 == rhsValue as! Float32)
            case .FLOAT64: (lhsValue as! Float64 == rhsValue as! Float64)
            case .SINT64: (lhsValue as! Int64 == rhsValue as! Int64)
            case .UINT64, .UINT64Z: (lhsValue as! UInt64 == rhsValue as! UInt64)
            case .STRING: (lhsValue as! String == rhsValue as! String)
            }
            
            guard isEqual else {
                return false
            }
        }
        return true
    }
    
    // MARK: Computed Properties
    var hasValues: Bool {
        return !values.isEmpty
    }
    
    var numValues: UInt8 {
        return UInt8(values.count)
    }
    
    var size: UInt8 {
        switch getBaseType() {
        case .STRING:
            var size:UInt8 = 0
            for value in values {
                let stringValue = String(anyValue: value)
                size += UInt8(stringValue.lengthOfBytes(using: .utf8) + 1)
            }
            return size
        default:
            return numValues * getBaseType().size
        }
    }
    
    func sizeAfterAddingValue(index: Int, value: Any?) -> Int {
        switch getBaseType() {
        case .STRING:
            var sizeOfStringBeingReplaced = 0;
            if(index < values.count) {
                let stringBeingReplaced = values[index] as! String
                sizeOfStringBeingReplaced = stringBeingReplaced.lengthOfBytes(using: .utf8) + 1
            }
            
            let stringValue = String(anyValue: value)
            return Int(size) + stringValue.lengthOfBytes(using: .utf8) + 1 - sizeOfStringBeingReplaced
        default:
            if(index < values.count) {
                return Int(size)
            }
            
            return Int(index + 1) * Int(getBaseType().size)
        }
    }
    
    func checkFieldSizeWithValue(index: Int, value: Any?) throws {
        let newSize = sizeAfterAddingValue(index: index, value: value)
        
        if(newSize > FIT.MAX_FIELD_SIZE) {
            throw FieldError.sizeOverflow(size: newSize)
        }
    }
    
    // MARK: Get String Helpers
    func getStringValue() -> String? {
        return getStringValue(index: 0, subField: nil)
    }
    
    func getStringValue(index: Int) -> String? {
        return getStringValue(index: index, subField: nil)
    }
    
    func getStringValue(index: Int, subFieldIndex: UInt16) throws -> String? {
        return try String(anyValue: getValue(index: index, subFieldIndex: subFieldIndex))
    }
    
    func getStringValue(index: Int, subFieldName: String) throws -> String? {
        return try String(anyValue: getValue(index: index, subFieldName: subFieldName))
    }
    
    func getStringValue(index: Int, subField: SubField?) -> String? {
        guard let value = getValue(index: index, subField: subField) else {
            return nil
        }

        return String(anyValue: value)
    }
}

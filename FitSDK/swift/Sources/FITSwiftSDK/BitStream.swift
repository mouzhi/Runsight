/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

public class BitStream {
    private static let BITS_PER_POSITION = 8

    private var bytes: [UInt8] = []
    
    public private(set) var position: Int = 0
    public private(set) var bitsAvailable: Int = 0

    private var currentByte: UInt8 = 0
    private var currentBit: Int = 0
    
    enum BitStreamError: Error {
        case noBitsAvailable
        case tooManyBitsRequested
    }
    
    public convenience init(value: any Numeric) throws {
        try self.init(values: [value])
    }
    
    public init(values: [any Numeric]) throws {
        for value in values {
            self.bytes += value.bytes
        }
        
        try self.reset()
    }
         
    func readBit() throws -> UInt8 {
        if (!hasBitsAvailable()) {
            throw BitStreamError.noBitsAvailable
        }
        
        if (currentBit >= BitStream.BITS_PER_POSITION) {
            try nextByte()
        }
        
        let bit = currentByte & 0x01
        currentByte = currentByte >> 1
        currentBit += 1
        bitsAvailable -= 1
        
        return bit
    }
    
    func readBits(_ nBitsToRead: Int) throws -> Int64 {
        if (nBitsToRead > 64) {
            throw BitStreamError.tooManyBitsRequested
        }
        
        var value: Int64 = 0
        
        for i in 0..<nBitsToRead {
            value |= Int64(try readBit()) << i
        }
        
        return value
    }
    
    public func reset() throws {
        position = 0
        bitsAvailable = BitStream.BITS_PER_POSITION * bytes.count
        try nextByte()
    }
    
    public func nextByte() throws {
        if (position >= bytes.count) {
            throw BitStreamError.noBitsAvailable
        }
        
        currentByte = bytes[position]
        position += 1

        currentBit = 0
    }
    
    public func hasBitsAvailable() -> Bool {
        return bitsAvailable > 0
    }
}

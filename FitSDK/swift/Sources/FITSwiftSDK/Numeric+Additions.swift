/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2025 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.171.0Release
// Tag = production/release/21.171.0-0-g57fed75
/////////////////////////////////////////////////////////////////////////////////////////////


import Foundation

func numericToFloatingPointCast<T: BinaryInteger, U: BinaryFloatingPoint>(_ x: T) -> U {
    return U(x)
}

func floatingPointToNumericCast<T: BinaryFloatingPoint, U: BinaryInteger>(_ x: T) -> U {
    return U(x)
}

// This is more or less a copy of numericCast()
func numericToNumericCast<T: BinaryInteger, U: BinaryInteger>(_ x: T) -> U {
    return U(x)
}

func floatingToFloatingCast<T: BinaryFloatingPoint, U: BinaryFloatingPoint>(_ x: T) -> U {
    return U(x)
}

extension Int8 {
    init<T:Any>(fitValue: T) {
        let value: Int8
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = Int8(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).int8Value
        default:
            fatalError()
        }
        self = value
    }
}

extension UInt8 {
    init<T:Any>(fitValue: T) {
        let value: UInt8
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = UInt8(stringProtocolValue, radix: 10)!
        case let boolValue as Bool:
            value = boolValue ? 1 : 0
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).uint8Value
        default:
            fatalError()
        }
        self = value
    }
}

extension Int16 {
    init<T:Any>(fitValue: T) {
        let value: Int16
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = Int16(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).int16Value
        default:
            fatalError()
        }
        self = value
    }
}

extension UInt16 {
    init<T:Any>(fitValue: T) {
        let value: UInt16
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = UInt16(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).uint16Value
        default:
            fatalError()
        }
        self = value
    }
}

extension Int32 {
    init<T:Any>(fitValue: T) {
        let value: Int32
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = Int32(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).int32Value
        default:
            fatalError()
        }
        self = value
    }
}

extension UInt32 {
    init<T:Any>(fitValue: T) {
        let value: UInt32
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = UInt32(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).uint32Value
        default:
            fatalError()
        }
        self = value
    }
}

extension Int64 {
    init<T:Any>(fitValue: T) {
        let value: Int64
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = Int64(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).int64Value
        default:
            fatalError()
        }
        self = value
    }
}

extension UInt64 {
    init<T:Any>(fitValue: T) {
        let value: UInt64
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToNumericCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingPointToNumericCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = UInt64(stringProtocolValue, radix: 10)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).uint64Value
        default:
            fatalError()
        }
        self = value
    }
}

extension Float32 {
    init<T:Any>(fitValue: T) {
        let value: Float32
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = numericToFloatingPointCast(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            value = floatingToFloatingCast(binaryFloatingPointValue)
        case let stringProtocolValue as any StringProtocol:
            value = Float32(stringProtocolValue)!
        case let decimalValue as Decimal:
            value = NSDecimalNumber(decimal: decimalValue).floatValue
        default:
            fatalError()
        }
        self = value
    }
}

extension Float64 {
    init<T:Any>(fitValue: T) {
        let value: Float64
        switch fitValue {
        case let binaryIntegerValue as any BinaryInteger:
            value = Float64(binaryIntegerValue)
        case let binaryFloatingPointValue as any BinaryFloatingPoint:
            if(binaryFloatingPointValue.isInfinite) {
                value = Float64.nan
                break
            }

            value = Float64(floatLiteral: Float64(binaryFloatingPointValue))
        case let stringProtocolValue as any StringProtocol:
            value = Float64(String(stringProtocolValue))!
        case let boolValue as Bool:
            value = Float64(boolValue ? 1 : 0)
        case let decimalValue as NSDecimalNumber:
            value = decimalValue.doubleValue
        default:
            fatalError()
        }
        self = value
    }
}

extension Numeric {
   var bytes: [UInt8] {
       withUnsafeBytes(of: self, Array.init)
   }
}
